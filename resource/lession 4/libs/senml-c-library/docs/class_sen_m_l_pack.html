<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>kpn-senml-C++: SenMLPack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kpn.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">kpn-senml-C++
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">generate and parse senml data from json or cbor</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sen_m_l_pack-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SenMLPack Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="senml__pack_8h_source.html">senml_pack.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SenMLPack:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sen_m_l_pack.png" usemap="#SenMLPack_map" alt=""/>
  <map id="SenMLPack_map" name="SenMLPack_map">
<area href="class_sen_m_l_base.html" alt="SenMLBase" shape="rect" coords="202,0,394,24"/>
<area href="class_sen_m_l_pack_template.html" alt="SenMLPackTemplate&lt; T &gt;" shape="rect" coords="0,112,192,136"/>
<area href="class_sen_m_l_pack_template.html" alt="SenMLPackTemplate&lt; double &gt;" shape="rect" coords="202,112,394,136"/>
<area href="class_sen_m_l_pack_template.html" alt="SenMLPackTemplate&lt; int &gt;" shape="rect" coords="404,112,596,136"/>
<area href="class_sen_m_l_double_pack.html" alt="SenMLDoublePack" shape="rect" coords="202,168,394,192"/>
<area href="class_sen_m_l_int_pack.html" alt="SenMLIntPack" shape="rect" coords="404,168,596,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf57e48a7ce125a8ee2e242db25b050a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#abf57e48a7ce125a8ee2e242db25b050a">SenMLPack</a> ()</td></tr>
<tr class="separator:abf57e48a7ce125a8ee2e242db25b050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24359b00418b93b6e12399f1df826871"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a24359b00418b93b6e12399f1df826871">SenMLPack</a> (const char *baseName)</td></tr>
<tr class="separator:a24359b00418b93b6e12399f1df826871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d36b75005abea48099e47c17a9f497"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ad9d36b75005abea48099e47c17a9f497">SenMLPack</a> (const char *baseName, SenMLUnit baseUnit)</td></tr>
<tr class="separator:ad9d36b75005abea48099e47c17a9f497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d327ddbe1b2d7dc7744f4555408155e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a8d327ddbe1b2d7dc7744f4555408155e">SenMLPack</a> (const char *baseName, SenMLUnit baseUnit, double baseTime)</td></tr>
<tr class="separator:a8d327ddbe1b2d7dc7744f4555408155e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d318be902f9cd8091438c450eaf5a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#aa3d318be902f9cd8091438c450eaf5a8">SenMLPack</a> (PACK_ACTUATOR_SIGNATURE)</td></tr>
<tr class="separator:aa3d318be902f9cd8091438c450eaf5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea0c0faad847d60bb62cbfae6f18b20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a9ea0c0faad847d60bb62cbfae6f18b20">SenMLPack</a> (const char *baseName, PACK_ACTUATOR_SIGNATURE)</td></tr>
<tr class="separator:a9ea0c0faad847d60bb62cbfae6f18b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eef4a1d7f8d9df6f520a25745442e04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a5eef4a1d7f8d9df6f520a25745442e04">SenMLPack</a> (const char *baseName, SenMLUnit baseUnit, PACK_ACTUATOR_SIGNATURE)</td></tr>
<tr class="separator:a5eef4a1d7f8d9df6f520a25745442e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44002e83b0bbe0b22ab5eb7424ecd4d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a44002e83b0bbe0b22ab5eb7424ecd4d5">SenMLPack</a> (const char *baseName, SenMLUnit baseUnit, double baseTime, PACK_ACTUATOR_SIGNATURE)</td></tr>
<tr class="separator:a44002e83b0bbe0b22ab5eb7424ecd4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dde197fad088b36663dbbc730381929"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a5dde197fad088b36663dbbc730381929">~SenMLPack</a> ()</td></tr>
<tr class="separator:a5dde197fad088b36663dbbc730381929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31a952f44bfd85a6662e21005f471d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ab31a952f44bfd85a6662e21005f471d4">toJson</a> (Stream *dest, SenMLStreamMethod format=SENML_RAW)</td></tr>
<tr class="separator:ab31a952f44bfd85a6662e21005f471d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25669b85436644c9165f2a0c9809ad1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a25669b85436644c9165f2a0c9809ad1d">toJson</a> (char *dest, int length, SenMLStreamMethod format=SENML_RAW)</td></tr>
<tr class="separator:a25669b85436644c9165f2a0c9809ad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3409b30affe5789672cae38fa5107a7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a3409b30affe5789672cae38fa5107a7f">toCbor</a> (Stream *dest, SenMLStreamMethod format=SENML_RAW)</td></tr>
<tr class="separator:a3409b30affe5789672cae38fa5107a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85a8f5ccf895f3d1bd520e8cf7ae497"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ab85a8f5ccf895f3d1bd520e8cf7ae497">toCbor</a> (char *dest, int length, SenMLStreamMethod format=SENML_RAW)</td></tr>
<tr class="separator:ab85a8f5ccf895f3d1bd520e8cf7ae497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bce14b1accf8c42bf43c7148cdfe6c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a2bce14b1accf8c42bf43c7148cdfe6c5">fromJson</a> (Stream *source, SenMLStreamMethod format=SENML_RAW)</td></tr>
<tr class="separator:a2bce14b1accf8c42bf43c7148cdfe6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7217d347222f4ad861e5d3c5d3bf7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a0c7217d347222f4ad861e5d3c5d3bf7d">fromJson</a> (const char *source)</td></tr>
<tr class="separator:a0c7217d347222f4ad861e5d3c5d3bf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8457d7bd6aceb332e517174c8d2955d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a8457d7bd6aceb332e517174c8d2955d8">fromCbor</a> (Stream *source, SenMLStreamMethod format=SENML_RAW)</td></tr>
<tr class="separator:a8457d7bd6aceb332e517174c8d2955d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a677be70364414a5e52c8bc766d22c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ad9a677be70364414a5e52c8bc766d22c">fromCbor</a> (char *source, int length, SenMLStreamMethod format)</td></tr>
<tr class="separator:ad9a677be70364414a5e52c8bc766d22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578bb9a2f57014e66e4e9fee2dfa2ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a578bb9a2f57014e66e4e9fee2dfa2ac3">setBaseName</a> (const char *name)</td></tr>
<tr class="separator:a578bb9a2f57014e66e4e9fee2dfa2ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f51a25c88327fa70ad0e8f4c0c60ea"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ac8f51a25c88327fa70ad0e8f4c0c60ea">getBaseName</a> ()</td></tr>
<tr class="separator:ac8f51a25c88327fa70ad0e8f4c0c60ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7259c855b57ff4865b85ae6b5c04ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#aee7259c855b57ff4865b85ae6b5c04ec">setBaseUnit</a> (SenMLUnit unit)</td></tr>
<tr class="separator:aee7259c855b57ff4865b85ae6b5c04ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebc4d1538d1067f3a3ccfdbf301d936"><td class="memItemLeft" align="right" valign="top">SenMLUnit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#adebc4d1538d1067f3a3ccfdbf301d936">getBaseUnit</a> ()</td></tr>
<tr class="separator:adebc4d1538d1067f3a3ccfdbf301d936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71f51e30a6dc59aed7f4156b5d50ad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ab71f51e30a6dc59aed7f4156b5d50ad1">setBaseTime</a> (double time)</td></tr>
<tr class="separator:ab71f51e30a6dc59aed7f4156b5d50ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb223b57db28a6a3b5270c6bf2977d56"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#afb223b57db28a6a3b5270c6bf2977d56">getBaseTime</a> ()</td></tr>
<tr class="separator:afb223b57db28a6a3b5270c6bf2977d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aac3df3b53b5dec5a6eef980ea55cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ac0aac3df3b53b5dec5a6eef980ea55cd">add</a> (<a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *item)</td></tr>
<tr class="separator:ac0aac3df3b53b5dec5a6eef980ea55cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1924fa9f7c7618d8db8f87a0529b09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ace1924fa9f7c7618d8db8f87a0529b09">clear</a> ()</td></tr>
<tr class="separator:ace1924fa9f7c7618d8db8f87a0529b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4252064e763d5c14fc3663c0ad6ed7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ac4252064e763d5c14fc3663c0ad6ed7e">getFirst</a> ()</td></tr>
<tr class="separator:ac4252064e763d5c14fc3663c0ad6ed7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7222ac1370777dea01f6b2917290c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#a6d7222ac1370777dea01f6b2917290c9">fieldsToJson</a> ()</td></tr>
<tr class="separator:a6d7222ac1370777dea01f6b2917290c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac758d0042f37dd9ca1f67445744d360b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_pack.html#ac758d0042f37dd9ca1f67445744d360b">fieldsToCbor</a> ()</td></tr>
<tr class="separator:ac758d0042f37dd9ca1f67445744d360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_sen_m_l_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_sen_m_l_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_sen_m_l_base.html">SenMLBase</a></td></tr>
<tr class="memitem:a485d74184b9f306c33ada3a925090b2d inherit pub_methods_class_sen_m_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_base.html#a485d74184b9f306c33ada3a925090b2d">getNext</a> ()</td></tr>
<tr class="separator:a485d74184b9f306c33ada3a925090b2d inherit pub_methods_class_sen_m_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776604afc6a8d2004117df22a4cc7d3a inherit pub_methods_class_sen_m_l_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sen_m_l_base.html#a776604afc6a8d2004117df22a4cc7d3a">getRoot</a> ()</td></tr>
<tr class="separator:a776604afc6a8d2004117df22a4cc7d3a inherit pub_methods_class_sen_m_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4c72cddddbd8a3279e4f01726486c inherit pub_methods_class_sen_m_l_base"><td class="memItemLeft" align="right" valign="top"><a id="abbe4c72cddddbd8a3279e4f01726486c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>adjustToBaseTime</b> (double prev, double time)</td></tr>
<tr class="separator:abbe4c72cddddbd8a3279e4f01726486c inherit pub_methods_class_sen_m_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7271a4395f15bd8510bef67ff2f7e3af"><td class="memItemLeft" align="right" valign="top"><a id="a7271a4395f15bd8510bef67ff2f7e3af"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPack</b> ()</td></tr>
<tr class="separator:a7271a4395f15bd8510bef67ff2f7e3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a0e223174cd3c8ff83e18022f681a5"><td class="memItemLeft" align="right" valign="top"><a id="ae6a0e223174cd3c8ff83e18022f681a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>actuate</b> (const char *pack, const char *record, const void *value, int valueLength, SenMLDataType dataType)</td></tr>
<tr class="separator:ae6a0e223174cd3c8ff83e18022f681a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb013cabffe51bd2f2e78721d240ce4"><td class="memItemLeft" align="right" valign="top"><a id="a3eb013cabffe51bd2f2e78721d240ce4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLast</b> (<a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *value)</td></tr>
<tr class="separator:a3eb013cabffe51bd2f2e78721d240ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a412128872868c27f789d3b0b24746"><td class="memItemLeft" align="right" valign="top"><a id="ad6a412128872868c27f789d3b0b24746"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>contentToCbor</b> ()</td></tr>
<tr class="separator:ad6a412128872868c27f789d3b0b24746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b4a2824ef2f65f3cdd6b13b2f30f0"><td class="memItemLeft" align="right" valign="top"><a id="a514b4a2824ef2f65f3cdd6b13b2f30f0"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getArrayLength</b> ()</td></tr>
<tr class="separator:a514b4a2824ef2f65f3cdd6b13b2f30f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05309beee724c28369fce1f3c02438f5"><td class="memItemLeft" align="right" valign="top"><a id="a05309beee724c28369fce1f3c02438f5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setupStreamCtx</b> (char *dest, int length, SenMLStreamMethod format)</td></tr>
<tr class="separator:a05309beee724c28369fce1f3c02438f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c139bf9ab42534469cdb944ac073762"><td class="memItemLeft" align="right" valign="top"><a id="a1c139bf9ab42534469cdb944ac073762"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setupStreamCtx</b> (Stream *dest, SenMLStreamMethod format)</td></tr>
<tr class="separator:a1c139bf9ab42534469cdb944ac073762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_sen_m_l_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_sen_m_l_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_sen_m_l_base.html">SenMLBase</a></td></tr>
<tr class="memitem:a1ba5a8e6cdeb300ba3ce19d268cc660a inherit pro_methods_class_sen_m_l_base"><td class="memItemLeft" align="right" valign="top"><a id="a1ba5a8e6cdeb300ba3ce19d268cc660a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNext</b> (<a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *value)</td></tr>
<tr class="separator:a1ba5a8e6cdeb300ba3ce19d268cc660a inherit pro_methods_class_sen_m_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5097934468e6c397e89a8daacbd323 inherit pro_methods_class_sen_m_l_base"><td class="memItemLeft" align="right" valign="top"><a id="a7e5097934468e6c397e89a8daacbd323"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPrev</b> (<a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *value)</td></tr>
<tr class="separator:a7e5097934468e6c397e89a8daacbd323 inherit pro_methods_class_sen_m_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3294f9d2980926114d5684d194a7122 inherit pro_methods_class_sen_m_l_base"><td class="memItemLeft" align="right" valign="top"><a id="aa3294f9d2980926114d5684d194a7122"></a>
<a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPrev</b> ()</td></tr>
<tr class="separator:aa3294f9d2980926114d5684d194a7122 inherit pro_methods_class_sen_m_l_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ade7d9590d5efa594d0d45220de7c0b4f"><td class="memItemLeft" align="right" valign="top"><a id="ade7d9590d5efa594d0d45220de7c0b4f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SenMLJsonListener</b></td></tr>
<tr class="separator:ade7d9590d5efa594d0d45220de7c0b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44ad3d3b4ad59fe9250ee91ff97d1c9"><td class="memItemLeft" align="right" valign="top"><a id="ad44ad3d3b4ad59fe9250ee91ff97d1c9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SenMLCborParser</b></td></tr>
<tr class="separator:ad44ad3d3b4ad59fe9250ee91ff97d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee937c4dfba681e9e19f9a785f852134"><td class="memItemLeft" align="right" valign="top"><a id="aee937c4dfba681e9e19f9a785f852134"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SenMLBase</b></td></tr>
<tr class="separator:aee937c4dfba681e9e19f9a785f852134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> represents a single senml document that can be sent or received.</p>
<p>A senmlPack object has SenMLRecords and/or other <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> objects as children. These represent the data that the object contains. A <a class="el" href="class_sen_m_l_record.html">SenMLRecord</a> represents a single value, while child SenMLPacks represent data of other devices. When a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> contains other <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> objects, the root object represents a gateway.</p>
<p>A <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object is able to render and parse the data to/from a json string or to/from binary CBOR data. Both rendering and parsing can be done either directly from a stream (like an UART connected to a modem), or from a memory buffer. Rendering to and parsing from a stream is useful for devices that have extreme low memory available. Almost no buffers are used in this case. Error handling is limited in this case though. The parser and generator are able to render in the native format (strings for json, binary data for cbor) and as a hex string. This is especially useful when directly working on a stream: some modems (ex lora) accept instructions with data in HEX format.</p>
<p>example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kpn_senml.h&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="class_sen_m_l_pack.html">SenMLPack</a> doc(<span class="stringliteral">&quot;device_name&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup(){</div><div class="line">    Serial.begin(57600);</div><div class="line">    senMLSetLogger(&amp;Serial);</div><div class="line">    delay(1000);</div><div class="line">    Serial.println(<span class="stringliteral">&quot;start&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> loop(){</div><div class="line">    <span class="keywordtype">int</span> val = 10;                                   <span class="comment">//just give it some value</span></div><div class="line">    <a class="code" href="class_sen_m_l_float_record.html">SenMLFloatRecord</a> rec(<span class="stringliteral">&quot;temp&quot;</span>, SENML_UNIT_DEGREES_CELSIUS, val);</div><div class="line">    doc.add(&amp;rec);                      </div><div class="line">    doc.toJson(&amp;Serial);                            <span class="comment">//as text</span></div><div class="line">    Serial.println();</div><div class="line">    doc.toJson(&amp;Serial, SENML_HEX);                 <span class="comment">//in hex format (often used in communication with lora modems)</span></div><div class="line">    Serial.println();</div><div class="line">    delay(1000);</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abf57e48a7ce125a8ee2e242db25b050a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf57e48a7ce125a8ee2e242db25b050a">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p>

</div>
</div>
<a id="a24359b00418b93b6e12399f1df826871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24359b00418b93b6e12399f1df826871">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>the string that will be prepended to all records in this pack. Is used to represent the name of the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9d36b75005abea48099e47c17a9f497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d36b75005abea48099e47c17a9f497">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLUnit&#160;</td>
          <td class="paramname"><em>baseUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>the string that will be prepended to all records in this pack. Is used to represent the name of the device. </td></tr>
    <tr><td class="paramname">baseUnit</td><td>the unit name that will be used by default if the record doesnt not define one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d327ddbe1b2d7dc7744f4555408155e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d327ddbe1b2d7dc7744f4555408155e">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLUnit&#160;</td>
          <td class="paramname"><em>baseUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>baseTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>the string that will be prepended to all records in this pack. Is used to represent the name of the device. </td></tr>
    <tr><td class="paramname">baseUnit</td><td>the unit name that will be used by default if the record doesnt not define one. </td></tr>
    <tr><td class="paramname">baseTime</td><td>the time that will be added to each record. When specified, each record that does not specify a time, will receive this time. When the record does have a time, the baseTime of the pack is added to it, so the time of the record becomes relative to that of the pack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3d318be902f9cd8091438c450eaf5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d318be902f9cd8091438c450eaf5a8">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramtype">PACK_ACTUATOR_SIGNATURE&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a function that will be called while parsing incomming data, when no record can be found that matches any of the defined ones in the object. The parameters of the callback must be: const char* packName the name of the pack that the record belongs to. The data is for a child <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> when this field is different then the name of the root pack. const char* recordName the name of the record const void* value a pointer to the memory blob that contains the actual value. int size the size of the memory blobl SenMLDataType dataType: defines how to interprete the memory blob (ex: pointer to integer,..) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ea0c0faad847d60bb62cbfae6f18b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea0c0faad847d60bb62cbfae6f18b20">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PACK_ACTUATOR_SIGNATURE&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>the string that will be prepended to all records in this pack. Is used to represent the name of the device. </td></tr>
    <tr><td class="paramname">callback</td><td>a function that will be called while parsing incomming data, when no record can be found that matches any of the defined ones in the object. The parameters of the callback must be: const char* packName the name of the pack that the record belongs to. The data is for a child <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> when this field is different then the name of the root pack. const char* recordName the name of the record const void* value a pointer to the memory blob that contains the actual value. int size the size of the memory blobl SenMLDataType dataType: defines how to interprete the memory blob (ex: pointer to integer,..) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5eef4a1d7f8d9df6f520a25745442e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eef4a1d7f8d9df6f520a25745442e04">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLUnit&#160;</td>
          <td class="paramname"><em>baseUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PACK_ACTUATOR_SIGNATURE&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>the string that will be prepended to all records in this pack. Is used to represent the name of the device. </td></tr>
    <tr><td class="paramname">baseUnit</td><td>the unit name that will be used by default if the record doesnt not define one. </td></tr>
    <tr><td class="paramname">callback</td><td>a function that will be called while parsing incomming data, when no record can be found that matches any of the defined ones in the object. The parameters of the callback must be: const char* packName the name of the pack that the record belongs to. The data is for a child <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> when this field is different then the name of the root pack. const char* recordName the name of the record const void* value a pointer to the memory blob that contains the actual value. int size the size of the memory blobl SenMLDataType dataType: defines how to interprete the memory blob (ex: pointer to integer,..) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44002e83b0bbe0b22ab5eb7424ecd4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44002e83b0bbe0b22ab5eb7424ecd4d5">&#9670;&nbsp;</a></span>SenMLPack() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::SenMLPack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLUnit&#160;</td>
          <td class="paramname"><em>baseUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>baseTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PACK_ACTUATOR_SIGNATURE&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>create a <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>the string that will be prepended to all records in this pack. Is used to represent the name of the device. </td></tr>
    <tr><td class="paramname">baseUnit</td><td>the unit name that will be used by default if the record doesnt not define one. </td></tr>
    <tr><td class="paramname">baseTime</td><td>the time that will be added to each record. When specified, each record that does not specify a time, will receive this time. When the record does have a time, the baseTime of the pack is added to it, so the time of the record becomes relative to that of the pack. </td></tr>
    <tr><td class="paramname">callback</td><td>a function that will be called while parsing incomming data, when no record can be found that matches any of the defined ones in the object. The parameters of the callback must be: const char* packName the name of the pack that the record belongs to. The data is for a child <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> when this field is different then the name of the root pack. const char* recordName the name of the record const void* value a pointer to the memory blob that contains the actual value. int size the size of the memory blobl SenMLDataType dataType: defines how to interprete the memory blob (ex: pointer to integer,..) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dde197fad088b36663dbbc730381929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dde197fad088b36663dbbc730381929">&#9670;&nbsp;</a></span>~SenMLPack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLPack::~SenMLPack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>destroys the <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0aac3df3b53b5dec5a6eef980ea55cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0aac3df3b53b5dec5a6eef980ea55cd">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SenMLPack::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sen_m_l_base.html">SenMLBase</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the specified SenML object to the document. The item will be appended to the end of the linked list. The item being added, can be a regular <a class="el" href="class_sen_m_l_record.html">SenMLRecord</a> or another <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object if you want to send data for multiple devices in 1 SenML message. Check the result of the function to see if the operation was successful or not. Possible reasons for failure:</p><ul>
<li>if the item being added is already part of a document. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>a pointer to a SenMlRecord or <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> that needs to be added to the document. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success, otherwise false. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ace1924fa9f7c7618d8db8f87a0529b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1924fa9f7c7618d8db8f87a0529b09">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SenMLPack::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear out the document and remove all the children. Children aren't destroyed, this is up to the developer. </p><dl class="section return"><dt>Returns</dt><dd>true (at the moment, the function does not yet return false as it doesn't detect any errors) </dd></dl>

</div>
</div>
<a id="ac758d0042f37dd9ca1f67445744d360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac758d0042f37dd9ca1f67445744d360b">&#9670;&nbsp;</a></span>fieldsToCbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SenMLPack::fieldsToCbor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>renders all the fields to cbor format. renders all the fields of the object without the length info at the beginning note: this is public so that custom implementations for the record object can use other objects internally and render to json using this function (ex: coordinatesRecord using 3 floatRecrods for lat, lon &amp; alt. </p><dl class="section return"><dt>Returns</dt><dd>: The number of bytes that were written. </dd></dl>

<p>Implements <a class="el" href="class_sen_m_l_base.html#a8e07467fb480251d15d6e1a0fa05429c">SenMLBase</a>.</p>

<p>Reimplemented in <a class="el" href="class_sen_m_l_double_pack.html#a66ab167a821e991e2ce76626e6c2e39f">SenMLDoublePack</a>, and <a class="el" href="class_sen_m_l_int_pack.html#afbdc8642692a24b56d69edef2ce2de36">SenMLIntPack</a>.</p>

</div>
</div>
<a id="a6d7222ac1370777dea01f6b2917290c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7222ac1370777dea01f6b2917290c9">&#9670;&nbsp;</a></span>fieldsToJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::fieldsToJson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>renders all the fields to json, without the starting and ending brackets. Inheriters can extend this function if they want to add extra fields to the json output note: this is public so that custom implementations for the record object can use other objects internally and render to json using this function (ex: coordinatesRecord using 3 floatRecrods for lat, lon &amp; alt. </p><dl class="section return"><dt>Returns</dt><dd>: None </dd></dl>

<p>Implements <a class="el" href="class_sen_m_l_base.html#ad38e2184902e9a695c61de3fae2d7f1b">SenMLBase</a>.</p>

<p>Reimplemented in <a class="el" href="class_sen_m_l_double_pack.html#a3851c65cb1a00a433f1b48f8f12013f0">SenMLDoublePack</a>, and <a class="el" href="class_sen_m_l_int_pack.html#a7087815e0e9219080b0841daf58cc357">SenMLIntPack</a>.</p>

</div>
</div>
<a id="a8457d7bd6aceb332e517174c8d2955d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8457d7bd6aceb332e517174c8d2955d8">&#9670;&nbsp;</a></span>fromCbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::fromCbor </td>
          <td>(</td>
          <td class="paramtype">Stream *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLStreamMethod&#160;</td>
          <td class="paramname"><em>format</em> = <code>SENML_RAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read and parse senml cbor from the specified source and, for each registered actuator, call the appropriate event on the actuator itself, for others, the callback function PACK_ACTUATOR_SIGNATURE will be called, if present. This method is ideal for devices with very littel ram memory. It will block on most decices if there is no more input to be read from the stream and the end of the cbor structure is not yet reached. Note: on mbed systems, the blocking nature is not garanteed. Instead, if no more data is available before the end is reached, parsing will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source stream to read the data from. </td></tr>
    <tr><td class="paramname">format</td><td>determins how the data will be read (ex: as normal binary or in HEX format). See SenMLStreamMethod for possible methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ad9a677be70364414a5e52c8bc766d22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a677be70364414a5e52c8bc766d22c">&#9670;&nbsp;</a></span>fromCbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::fromCbor </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLStreamMethod&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>parse senml cbor from the specified memory and, for each registered actuator, call the appropriate event on the actuator itself, for others, the callback function PACK_ACTUATOR_SIGNATURE will be called, if present. This method takes a memory blob as input. The data must be fully defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source data to use as input. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the source data. </td></tr>
    <tr><td class="paramname">format</td><td>determins how the data will be read (ex: as normal binary or in HEX format). See SenMLStreamMethod for possible methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a2bce14b1accf8c42bf43c7148cdfe6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bce14b1accf8c42bf43c7148cdfe6c5">&#9670;&nbsp;</a></span>fromJson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::fromJson </td>
          <td>(</td>
          <td class="paramtype">Stream *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLStreamMethod&#160;</td>
          <td class="paramname"><em>format</em> = <code>SENML_RAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read and parse a senml json string from the specified source and, for each registered actuator, call the appropriate event on the actuator itself, for others, the callback function PACK_ACTUATOR_SIGNATURE will be called, if present. This method is ideal for devices with very littel ram memory. It will block on most devices if there is no more input to be read from the stream and the end of the json structure is not yet reached. Note: on mbed systems, the blocking nature is not garanteed. Instead, if no more data is available before the end is reached, parsing will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source stream to read the data from. </td></tr>
    <tr><td class="paramname">format</td><td>determins how the data will be read (ex: as normal text or in HEX format). See SenMLStreamMethod for possible methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a0c7217d347222f4ad861e5d3c5d3bf7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7217d347222f4ad861e5d3c5d3bf7d">&#9670;&nbsp;</a></span>fromJson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::fromJson </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>parse a senml json string from the specified source and, for each registered actuator, call the appropriate event on the actuator itself, for others, the callback function PACK_ACTUATOR_SIGNATURE will be called, if present. This method takes a string stored in memory as input. The json must be fully defined. It is up to the caller to transform it to a regular text string, if needed (ex: lora devices might send it in hex format). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source string to use as input. This must be null terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ac8f51a25c88327fa70ad0e8f4c0c60ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f51a25c88327fa70ad0e8f4c0c60ea">&#9670;&nbsp;</a></span>getBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * SenMLPack::getBaseName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the base name. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-13#section-4.1">base fields</a> for more info. </p><dl class="section return"><dt>Returns</dt><dd>the name of the device as an immutable string. </dd></dl>

</div>
</div>
<a id="afb223b57db28a6a3b5270c6bf2977d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb223b57db28a6a3b5270c6bf2977d56">&#9670;&nbsp;</a></span>getBaseTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SenMLPack::getBaseTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the base time. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-13#section-4.1">base fields</a> for more info. </p><dl class="section return"><dt>Returns</dt><dd>a double value that is used as the default unit for records that don't define a unit of their own. if no base time is set, NaN will be returned. </dd></dl>

</div>
</div>
<a id="adebc4d1538d1067f3a3ccfdbf301d936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebc4d1538d1067f3a3ccfdbf301d936">&#9670;&nbsp;</a></span>getBaseUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SenMLUnit SenMLPack::getBaseUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the base unit. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-13#section-4.1">base fields</a> for more info. </p><dl class="section return"><dt>Returns</dt><dd>a SenMLUnit enum value that is used as the default unit for records that don't define a unit of their own. </dd></dl>

</div>
</div>
<a id="ac4252064e763d5c14fc3663c0ad6ed7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4252064e763d5c14fc3663c0ad6ed7e">&#9670;&nbsp;</a></span>getFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sen_m_l_base.html">SenMLBase</a>* SenMLPack::getFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the first recrod of in this pack element. </p><dl class="section return"><dt>Returns</dt><dd>null when this object is empty (has no children), otherwise, the first item (<a class="el" href="class_sen_m_l_record.html">SenMLRecord</a> or <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a>) of the list. </dd></dl>

</div>
</div>
<a id="a578bb9a2f57014e66e4e9fee2dfa2ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578bb9a2f57014e66e4e9fee2dfa2ac3">&#9670;&nbsp;</a></span>setBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::setBaseName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>assign a basename to the <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object. This represents the name of the device. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-13#section-4.1">base fields</a> for more info. Every <a class="el" href="class_sen_m_l_pack.html">SenMLPack</a> object must have a basename. This field will always be rendered in the output, even if the string is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>an immutable string that will be used to represent the name of the device. An internal copy of the value will be made. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ab71f51e30a6dc59aed7f4156b5d50ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71f51e30a6dc59aed7f4156b5d50ad1">&#9670;&nbsp;</a></span>setBaseTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::setBaseTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the base time. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-13#section-4.1">base fields</a> for more info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the value to use as base time. set bt to NaN if the field should not be included in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="aee7259c855b57ff4865b85ae6b5c04ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7259c855b57ff4865b85ae6b5c04ec">&#9670;&nbsp;</a></span>setBaseUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::setBaseUnit </td>
          <td>(</td>
          <td class="paramtype">SenMLUnit&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the base unit that will be used as the default unit for all records that don't define their own unit. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-13#section-4.1">base fields</a> for more info. Set to SENML_UNIT_NONE for ommiting the base unit from the output (default). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td>the unit to use as default. See SenMLUnit for all supported unit names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a3409b30affe5789672cae38fa5107a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3409b30affe5789672cae38fa5107a7f">&#9670;&nbsp;</a></span>toCbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SenMLPack::toCbor </td>
          <td>(</td>
          <td class="paramtype">Stream *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLStreamMethod&#160;</td>
          <td class="paramname"><em>format</em> = <code>SENML_RAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>render the content of the current object to cbor data (binary). This function is ideal for devices with low memory usage but offers less control over the rendering process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination stream to where the data will be rendered without buffering it in memory </td></tr>
    <tr><td class="paramname">format</td><td>determins how the data will be rendered. See SenMLStreamMethod for possible methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nr of bytes that were rendered </dd></dl>

</div>
</div>
<a id="ab85a8f5ccf895f3d1bd520e8cf7ae497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85a8f5ccf895f3d1bd520e8cf7ae497">&#9670;&nbsp;</a></span>toCbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SenMLPack::toCbor </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLStreamMethod&#160;</td>
          <td class="paramname"><em>format</em> = <code>SENML_RAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>render the content of the current object to cbor data (binary). This function renders the data to a memory buffer. If the buffer is full before the entire object is rendered, an error will be written to the debug stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>a memory buffer to which the data will be rendred. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the memory buffer. </td></tr>
    <tr><td class="paramname">format</td><td>determins how the data will be rendered. See SenMLStreamMethod for possible methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nr of bytes that were rendered </dd></dl>

</div>
</div>
<a id="ab31a952f44bfd85a6662e21005f471d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31a952f44bfd85a6662e21005f471d4">&#9670;&nbsp;</a></span>toJson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::toJson </td>
          <td>(</td>
          <td class="paramtype">Stream *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLStreamMethod&#160;</td>
          <td class="paramname"><em>format</em> = <code>SENML_RAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>render the content of the current object to json data (string). This function is ideal for devices with low memory usage but offers less control over the rendering process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination stream to where the data will be rendered without buffering it in memory </td></tr>
    <tr><td class="paramname">format</td><td>determins how the data will be rendered. See SenMLStreamMethod for possible methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="a25669b85436644c9165f2a0c9809ad1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25669b85436644c9165f2a0c9809ad1d">&#9670;&nbsp;</a></span>toJson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SenMLPack::toJson </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SenMLStreamMethod&#160;</td>
          <td class="paramname"><em>format</em> = <code>SENML_RAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>render the content of the current object to json data (string). This function renders the data to a memory buffer. If the buffer is full before the entire object is rendered, an error will be written to the debug stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>a memory buffer to which the data will be rendred. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the memory buffer. </td></tr>
    <tr><td class="paramname">format</td><td>determins how the data will be rendered. See SenMLStreamMethod for possible methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="senml__pack_8h_source.html">senml_pack.h</a></li>
<li>senml_pack.cpp</li>
</ul>
</div><!-- contents -->
copyright © 2018 KPN 